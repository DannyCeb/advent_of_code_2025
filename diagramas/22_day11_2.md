```mermaid
graph TD
    subgraph "Lógica Principal (main)"
        A[Inicio] --> B{Parsear 'day11.txt' y construir grafo};
        B --> C{Inicializar un caché 'memo' vacío};
        C --> D{Llamar a la función recursiva dfs:<br/>dfs("svr", "out", false, false, ...)}
        D --> E{Imprimir el resultado devuelto por dfs};
        E --> F[Fin];
    end

    subgraph "Función dfs(node, target, has_dac, has_fft, memo)"
        G[Entrada] --> H{Crear clave para el caché:<br/>key = (node, has_dac, has_fft)};
        H --> I{¿Está 'key' en el caché 'memo'?};
        I -- Sí --> J{Retornar valor del caché};
        I -- No --> K{Caso Base: ¿Es 'node' el 'target' ("out")?};
        K -- Sí --> L{¿Se han visitado 'dac' Y 'fft'?<br/>(has_dac && has_fft)};
        L -- Sí --> M{Retornar 1};
        L -- No --> N{Retornar 0};
        
        K -- No --> O{Actualizar Banderas:<br/>Si node == "dac", has_dac = true<br/>Si node == "fft", has_fft = true};
        O --> P{Paso Recursivo: Inicializar sum = 0};
        P --> Q{Para cada vecino 'nei' del 'node' actual};
        Q -- Llamada recursiva --> R{sum += dfs(nei, target, has_dac, has_fft, memo)};
        R --> Q;
        Q -- Fin de vecinos --> S{Guardar 'sum' en el caché con la 'key'};
        S --> T{Retornar 'sum'};
    end

    style F fill:#2E8B57,color:#fff
```
